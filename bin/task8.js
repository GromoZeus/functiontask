// Реализуйте функцию, которая объединяет несколько словарей (объектов)
//  в один общий словарь. Функция принимает любое количество аргументов и возвращает
//  результат в виде объекта, в котором каждый ключ содержит список уникальных значений
//  в виде массива. Элементы в списке располагаются в том порядке, в котором они появляются
//  во входящих словарях.

const merge = (...obj) => obj.reduce((acc, element) => {
  const keys = Object.keys(element);
  keys.forEach((key) => {
    if (!Object.hasOwn(acc, key)) {
      acc[key] = [];
    }
    if (!acc[key].includes(element[key])) {
      acc[key].push(element[key]);
    }
  });
  return acc;
}, {});

console.log(merge({}, {}, {}));
// {}

console.log(merge({ a: 1, b: 2 }, { a: 3 }));
// { a: [1, 3], b: [2] }

console.log(merge(
  { a: 1, b: 2, c: 3 },
  {},
  { a: 3, b: 2, d: 5 },
  { a: 6 },
  { b: 4, c: 3, d: 2 },
  { e: 9 },
));
// { a: [1, 3, 6], b: [2, 4], c: [3], d: [5, 2], e: [9] }

console.log(merge(
  { a: 1, b: 2 },
  { a: 3, c: 0 },
));
// { a: [1, 3], b: [2], c: [0] }

console.log(merge(
  { a: 1, b: 2, c: 3 },
  { a: 3, b: 4 },
  { a: 7, c: 1, d: 8 },
));
// { a: [1, 3, 7], b: [2, 4], c: [3, 1], d: [8] }

console.log(merge(
  { a: 1, b: 2, c: 3 },
  { a: 3, b: 4 },
  { a: 3, b: 2, d: 5 },
));
// { a: [1, 3], b: [2, 4], c: [3], d: [5] }
